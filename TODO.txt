NOTES and TODOS about Cairo and OOFCanvas


In Cairo, drawing needs to be done inside the callback for the gtk
expose_event.

Adding a CanvasItem to a Canvas or layer adds it to the Canvas or
layer's list of items.  Each item can compute its bounding box in
user coordinates, but some might need to know the canvas's ppu in
order to do so.

In the expose event's callback:
  Get the exposed rectangle (GdkRectangle GdkExposeEvent::area)
  Convert rectangle to physical coordinates
  Loop over all layers from bottom to top:
     Loop over all items in layer from first to last:
        If item's bbox intersects exposed bounding box in physical coords:
	    Draw item
	    
Each layer has its own Cairo Surface.  Each draws to its own
Surface and the Surfaces are then drawn with appropriate masks and
transparency to the final Surface (belonging to the gtk Layout).

Adding a CanvasItem to a CanvasLayer does not automatically draw it on the
layer.  It can't be drawn until the layer's Cairo::Surface is created,
and that can't be created until all layers' bounding boxes are known.
Bounding boxes depend on all the items in the Layer as well as the
ppu.  So CanvasItems need to be able to compute their bounding boxes
before CanvasItem::draw is called, but after the ppu is known.

CanvasLayer::dirty indicates that a layer needs to redraw itself to
its Surface.  Adding a CanvasItem to a layer automatically sets
dirty=true, but (TODO) it needs to be set manually if an item's parameters
change after it's been added to a layer.

CanvasLayers own the CanvasItems that have been added to them, and
will delete them when the layer is destroyed. So CanvasItems should
always be allocated with "new".  TODO: Should the constructors be
private, and only accessible to a factory method?

---

Mouse clicks:

* Each CanvasItem knows its bounding box and can say whether a mouse
  click at a particular user coordinate hits it.

* Each CanvasLayer has a set of bins and knows which CanvasItems'
  bounding boxes overlap each bin.  Or use an R-tree?

* Given a mouse click position, compute which bin it's in (or bins, if
  on a boundary), find the CanvasItems whose bounding boxes overlap
  the bin(s), and ask each CanvasItem if the click hits them.  Return
  a list of CanvasItems.

---

Rubberbands:

Old way: canvas calls RubberBand::start() and RubberBand::move() on mouse
motion, RubberBand::stop() on mouse up.
RubberBand derived classes draw themselves.

New way?  Allow more complicated operations, such as
down-up-move-down-up-move-down-up which could draw a triangle.  The
RubberBand object will be given every mouse event and will tell the
Canvas when it is done.  (Maybe later.)

If a rubberband is dragged outside the canvas, the canvas should
scroll in the opposite direction, leaving the dragged point on the
edge of the canvas.

Any CanvasItem used as a rubberband should have its linewidth settable
in device units.  Should *all* CanvasItem::setLineWidth methods take a
second argument that says whether the width is in pixels or user
units?

RubberBand bbox needs to be computed when computing the overall bbox,
or it won't be drawn if it extends outside the other layers.  But will
that force other layers to be recomputed?  That might be bad.

---

Do we want to support different scales in the x and y directions?
CanvasDot and CanvasLayer::pixel2user(double) assume that the scales
are the same.

---

Define CanvasGroup to allow a combination of objects to be defined and
duplicated at different positions and scales?

Should objects be changeable?  When an object is added, removed, or
changed, should the layer be told so that just some part of it can be
updated?  Or is Cairo already taking care of all that for us?

Should default values for parameters be settable?  After calling
CanvasText::setFont, should the next text item created automatically
use the same font?

Should it be possible to set line widths in device units as well as
user units?


Do use OOFCanvas::Coord and OOFCanvas::ICoord in the API.  Avoiding
them is silly since we're already exposing OOFCanvas::Color.

All linewidths should have the option of being specified in device
units, so that the CanvasItems can be used as rubberbands.

For CanvasImage, can zoom and scroll values be set so that image
pixels are integer numbers of display pixels and aligned to them?
Would this fix the blurriness caused by antialiasing?
