
# OOFCanvas summary

**NOTE:** this document is a work in progress, and is probably incomplete and
incorrect in places.

Please see the **Disclaimer and Copyright** notice at the bottom of this
document.

OOFCanvas is a replacement for libgnomecanvas, designed for use in
OOF2, but hopefully useful elsewhere. OOFCanvas is based on
[Cairo](https://www.cairographics.org/) and is compatible with gtk3.
It might eventually also be compatible with gtk+2.

OOF2 used [libgnomecanvas](https://developer.gnome.org/libgnomecanvas/)
to display and interact with images and meshes.  But libgnomecanvas
requires gtk+2, and gtk+2 works only with Python3, not Python2, and
Python2 is being phased out.  In order to upgrade OOF2 to Python3, we
need to first upgrade it from gtk+2 to gtk+3, and to do that we need
to first replace libgnomecanvas.

The canvas is a drawing area that can display a variety of shapes,
including text. It can be scrolled, zoomed, and printed.  Items drawn
on the canvas can be selected with the mouse.

OOFCanvas is *not* a drop-in replacement for libgnomecanvas.  It's
also not a full-fledged gtk widget.  It's a set of classes that does
some of what libgnomecanvas did and uses gtk.

All of the code is in C++.  Wrappers for Python 2.7 have been
generated by an old version of [SWIG](http://swig.org/), which is included in OOFCanvas.
Wrappers for Python 3 will be forthcoming.

### Installation

These instructions assume that you're familiar with using unix
commands in a terminal window.

1. Prerequisites:  Install the following packages:
   * Gtk3, version 3.22.0 or later, and its Python2 interface
   * CairoMM, version 1.12 or later
   * Pango, version 1.40 or later
   * PangoCairo, version 1.40 or later
   * ImageMagick, version 6.0 or later (optional)
   
	   We don't really know the minimum acceptable version numbers for the
	   prerequisites.  These are the ones that we've been able to use and
	   test.  It's quite possible that earlier versions will work as well.
   
   On a Mac using MacPorts, it's sufficient to install the packages
   `py27-gobject3`, `gtk3`, `cairomm`, `imagemagick`, and
   `adwaita-icon-theme`, as well as their automatically installed
   dependencies.
   
   On Ubuntu (and probably Debian, possibly other Linuxes), install
   `libcairomm-1.0-dev`, `libgtk-3-dev`, `python-gi-cairo`,
   `python-gi-dev`, and `imagemagick`, as well as their automatically
   installed dependencies.
   
   This is not an endorsement of Apple, MacPorts, Ubuntu, Debian or
   any other commercial or open source entity. These are just the
   systems that we have available for testing.  If you install
   OOFCanvas on a different system and tell us what you did, let us
   know and we'll include it here.

1. Download the OOFCanvas tar file from
   <https://www.ctcms.nist.gov/oof/oofcanvas/>.  

1. Unpack the tar file: 

	```
	tar -xf oofcanvas-1.0.0.tgz
	```
	(changing the version number if necessary).

1. Go to the OOFCanvas directory: 

   ```
   cd oofcanvas-1.0.0
   ```

1. Build OOFCanvas:

	```
	python setup.py build install --pythonAPI --magick
	```
   
   * If you want to install it in a non-standard location, add
	 `--prefix=/path/to/location` after `install`.  The default location
	 is system dependent, but is something like `/usr/local`, where
	 you might not have permission to create files.  To install in your
	 home directory, use `--prefix=$HOME`.
   
   * If you don't want to build the Python2 API, omit `--pythonAPI`.
   
   * If you don't want to be able to load and display images using
	 ImageMagick, omit `--magick`.  If you *do* want them, you will need
	 to have ImageMagick and its C++ library installed.
   
   * You can run the build and install steps separately, if you need
	 to use `sudo` to get permission to install in a particular
	 location.  Just remember to use `--pythonAPI --magick` in both
	 steps if you use them in one:

	~~~
	python setup.py build --pythonAPI --magick
	sudo python setup.py install --pythonAPI --magick
	~~~

6. When building a program that *uses* OOFCanvas, use the compiler
   and linker options provide by `pkg-config oofcanvas`:

		c++ `pkg-config --cflags oofcanvas` -c myfile.cpp ...
		c++ `pkg-config --libs oofcanvas` myfile.o ... -o myapp
		
		
	If you've installed OOFCanvas in a nonstandard location, you may
    have to tell pkg-config where it is by setting the environment
    variable `PKG_CONFIG_PATH`, _e.g._
	
	```
	export PKG_CONFIG_PATH=<prefix>/lib/pkgconfig
	```
	
	where `prefix` is the value you used with the `--prefix`
    installation option.
	
# Programming with OOFCanvas

All the classes and functions described here are defined in the C++
`OOFCanvas` namespace.  For simplicity we haven't included it
explicitly in the discussion below. 

## Header files

`<prefix>/include/oofcanvas/oofcanvas.h` declares all OOFCanvas
classes, functions, and constants that *don't* use the GUI.
If your program uses `pkg-config oofcanvas` to build, then you can use

```C++
#include "oofcanvas/oofcanvas.h"
```

in C++, or

```python
import oofcanvas
```

in Python.

will find this file.  The GUI dependent components of OOFCanvas are
defined in

```C++
#include "oofcanvas/oofcanvasgui.h"
```


## Class Overview

In general, you create a Canvas object and add it to your Gtk3 user
interface.  The Canvas contains CanvasLayers, and CanvasLayers contain
CanvasItems, such as lines, circles, and text.  Items have positions,
sizes, and colors, among other attributes.  The Canvas can be zoomed
and scrolled.  Layers are ordered, with higher layers (added later)
hiding lower layers (added earlier), although layers can also be
translucent, allowing lower layers to be seen. Layers can be reordered.

Mouse clicks and motions on the canvas can invoke a callback function.
		
### Coordinate Systems

There are two important coordinates systems: user coordinates and
pixel coordinates.

*Pixel* coordinates measure distance in pixels, with x increasing from
left to right and y increasing from top to bottom.  The origin is at
the upper left corner of the Canvas, which may or may not be visible
on the screen.

Items drawn on the canvas are specified in *user* coordinates, which
may be anything convenient to the user.  x goes from left to right on
the screen, and **y goes from bottom to top**.  This is not the
convention in many graphics libraries, but is standard in math,
physics, and the real world.

The conversion from user to pixel coordinates depends on the size
of the canvas and the current zoom factor, and determines the `ppu`
(pixels per unit).  Almost all objects in OOFCanvas are specified in
user coordinates, so the user does not need to worry about the pixel
coordinate system at all.  The one exception is that the *sizes* of
some objects can be specified in pixels.


### The Canvas Classes

Three kinds of Canvas objects are defined.

* `OffScreenCanvas` is the base class.  It can be used to make drawings
that will be printed or saved to a file, but not displayed.

* `Canvas `is derived from `OOFScreenCanvas`.  It creates a
`Gtk.Layout` which can be used in Gtk3 to put the `Canvas` in a GUI.
It calls user-provided callback functions in response to mouse events.

* A slightly different `Canvas` class is available in Python.  It's
actually a C++ class called `PythonCanvas`, which is renamed to
"Canvas" when exported to Python.  The main difference between the C++
and Python `Canvas` classes is that the Python class expects callback
functions to be Python methods, and the `GtkLayout` is created in
Python.

The pixel size of a `Canvas` or `PythonCanvas` is determined by the Gtk
window that it's part of.  The pixel size of an `OffScreenCanvas` is
only computed when it's saved as an image and the size of the image is
given.

### The CanvasLayer Class

Drawing is done by creating one or more `CanvasLayers` and adding
`CanvasItems` to them.  `CanvasLayers` can be shown, hidden, and
reordered, making it easy to change what's visible on the canvas.
Opaque items in higher layers obscure the items in lower layers.  A
newly created layer is always topmost.

`CanvasLayers` are created by calling `OffScreenCanvas::newLayer()` and
destroyed by calling either `CanvasLayer::destroy()` or
`OffScreenCanvas::deleteLayer()`.

The size of a layer in pixels is determined by the sizes (in user
coordinates) of the items being displayed, and the current `ppu`.

### The CanvasItem Classes

Everything drawn on a `Canvas` is an instance of a `CanvasItem` subclass.
Pointers to `CanvasItem`s are passed to `CanvasLayer::addItem`.  The
`CanvasLayer` will destroy its `CanvasItem`s when appropriate -- the user
should never destroy them explicitly. 

Each `CanvasItem` has a bunch of parameters that determine its position,
shape, color, and transparency.  Position parameters are always given
in user coordinates.  Some parameters, such as line widths, can be
given in either user or pixel units.

Details of each `CanvasItem` subclass are given [somewhere
below](#canvasitems).

### Basic Usage

In C++

```c++
#include "oofcanvas/guicanvas.h" // gui-dependent classes (Canvas, Rubberband)
#include "oofcanvas/oofcanvas.h" // everything else

double ppu; // pixels per unit -- initialize to something sensible
// Create a Canvas
Canvas canvas(ppu);
// Get a pointer to the GtkLayout widget
GtkWidget *widget = canvas.gtk(); 

// Install the canvas in the gui.  For example, if it's going into
// a GtkFrame,
frame.add(widget);

// Create a canvas layer
CanvasLayer *layer = canvas.newLayer("layername");

// Add items to the layer
double x=1., y=2., radius=1.4;  
CanvasCircle *circle = new CanvasCircle(x, y, radius); // In user coordinates.
circle->setLineWidthInPixels(1.5); // In pixel units
Color orange(1., 0.7, 0.0, 0.5); // r, g, b, a, all in [0.0, 1.0]
circle.setFillColor(orange);
layer->addItem(circle);

// Add more items if you want
...

// Draw the items to the canvas
canvas.draw();
```

The equivalent Python is virtually identical

```python
import oofcanvas
from oofcanvas import oofcanvasgui
canvas = oofcanvasgui.Canvas(width=300, height=300, ppu=1.0,
                             vexpand=True, hexpand=True)
frame.add(canvas.layout)

layer = oofcanvas.CanvasLayer()

x = 1.
y = 2.
radius = 1.4
circle = CanvasCircle(x, y, radius)
circle.setLineWidthInPixels(1.5)
orange = oofcanvas.Color(1., 0.7, 0.0, 0.5)
circle.setFillColor(orange)
layer.addItem(circle)

canvas.draw()
```

Calling `Canvas::draw` doesn't actually draw anything.  Instead, it
generates a Gtk event that causes the real drawing method to be called
from the Gtk main loop.

### Mouse 

The Canvas's `setMouseCallback` method installs a mouse event handler,
which will be called whenever a mouse button is pressed or released,
the mouse is moved, or the scroll wheel is turned.


Call `Canvas::setMouseCallback(MouseCallback callback, void *data)` to
install a mouse event handler.  `callback` will be called whenever a
mouse button is pressed, the mouse is moved, or the window is
scrolled.

To install a rubberband that will be displayed when the mouse is
moving, call `Canvas::setRubberBand(RubberBand*)` from the callback
for the mouse-down event.  The various types of `RubberBand` and
details of how to use them are described in the section on the
`RubberBand` class, below.  To stop displaying the `RubberBand`, pass
a null pointer (in C++) or `None` in (in Python) to `setRubberBand()`.

OOFCanvas does not handle selection of objects with the mouse, but it
does provide the position of a mouse click as part of the data passed
to the callback function.  Additionally, it is possible to get a list
of all `CanvasItems` at a point with
`OffScreenCanvas::clickedItems(const Coord&)`.

### Scrolling

A canvas can be scrolled in one of two ways.  It can be connected to
`GtkScrollBar`s or other widgets elsewhere in the GUI, and it can respond
to `scroll` events generated within the `GtkLayout`.

To connect to scroll bars, call `scrollbar.set_adjustment(adj)` (in
Python) or `gtk_range_set_adjustment(scrollbar, adj)` (in C++),
where `adj` is the `GtkAdjustment` returned by
`Canvas::getHAdjustment()` or `Canvas::getVAdjustment()`.

If the `GtkLayout` receives a scroll event, the mousehandler is called
with `event` set to `scroll`.  The `x` and `y` values are the changes
in position, and can be used to modify the adjustments of the scroll
bars:

```python
def mouseCB(eventtype, x, y, button, shift, ctrl, data):
	if eventtype == "scroll":
		sx = horizontalScrollBar.get_adjustment().get_value()
		horizontalScrollBar.get_adjustment().set_value(sx + x)
		...
```


## Details of the OOFCanvas Classes

This section contains detailed information about all of the externally
visible classes in OOFCanvas, starting with the utility classes that
are used by the rest of the code.

### Utility Types: Color, Coord, etc.

These classes are defined in the OOFCanvas namespace and are used for
some arguments and return values by the main OOFCanvas methods.

#### `Coord`

`Coord` is a position in user coordinates, the coordinate system in
which `CanvasItems` are defined.

The `Coord` class is defined in C++, but not in Python.  Methods that
return a position to Python simply return a tuple, (x,y).  When an
OOFCanvas function in Python requires a position argument, any type
that can be indexed can be used.  That is, if you have a coordinate
class called `MyCoord`, you can do this:

```python
pt = MyCoord(x, y)
circle = oofcanvas.CanvasCircle(pt, 1.0)
```
as long as `pt[0]` is x and `pt[1]` is y.  When an OOFCanvas function
returns a `Coord`, it's really returning a tuple, so you can do this:

```python
pt = MyCoord( * oofcanvas.someFunctionReturningACoord() )
```

Whenever a C++ function described below returns a `Coord`, assume that
the Python version works as described above.

The `Coord` constructors are

* `Coord()`

	creates a point at the origin.
	
* `Coord(double x, double y)`

	creates a point at (x,y).
	
The components can be accessed via the x and y data members or via
indexing.  `coord.x == coord[0]`.

Basic arithmetic, assignment, and equality operations are
supported. `Coord::norm2()` returns the square of the L2 norm.
`Coord::operator*(const Coord&)` is the dot product, and
`cross(const Coord&, const Coord&)` is the cross product.

#### `ICoord`

An `ICoord` is a Coord with integer coefficients, used to identify pixels.

#### `Rectangle`

The `Rectangle` class is not the same as the `CanvasRectangle`,
described below.  `CanvasRectangle` is a `CanvasItem` that can be
displayed. `Rectangle` is just a region of space.

A `Rectangle` can be constructed in several ways:

* `Rectangle()` creates an empty uninitialized rectangle at an
  undefined position.
* `Rectangle(double x0, double y0, double x1, double y1)` creates a
  rectangle with diagonally opposite corners at (x0, y0) and (x1,
  y1).  It doesn't matter which pair of diagonally opposite corners are
  given. 
* `Rectangle(const Coord &pt0, const Coord &pt1)` does the same, with
  `Coords` instead of `doubles`.
* From Python, only `Rectangle((x0, y0), (x1, y1))` is available.

Useful methods are

* `double Rectangle::xmin() const`
* `double Rectangle::ymin() const`
* `double Rectangle::xmax() const`
* `double Rectangle::ymax() const`
* `Rectangle::swallow(const Coord&)` expands the rectangle to include
  the given point.
	  
	  If the rectangle was uninitialized, this initializes it to an
      rectangle of size 0 at the given point.  That is,
	  `Rectangle r; r.swallow(pt);` is the same as `Rectangle r(pt,
      pt);` for some `Coord pt`.

* `Rectangle::swallow(const Rectangle&)` expands the rectangle include
  the given `Rectangle`.

#### `Color`

Colors are stored as RGBA values, which are doubles between 0 and 1.

C++ Constructors:

* `Color()`

	Initializes to black.

* `Color(double r, double g, double b)`

	Alpha is 1 (opaque).
	
* `Color(double r, double g, double b, double a)`

The only Python constructor is

* `Color(r, g, b)`

To change the opacity of a Python color, use

* `Color Color::opacity(alpha)`

which returns a new `Color` with the given opacity and the same RGB values.

Predefined constants are defined for `black`, `white`, `red`, `green`,
`blue`, `gray`, `yellow`, `magenta`, and `cyan`.

### Canvas Classes

#### OffScreenCanvas

`OffScreenCanvas` is the base class for the other Canvas classes.  As
the name implies, it can't be displayed on the screen, but it can be
drawn to and the resulting image can be saved to a file.

`OffScreenCanvas` exists in both C++ and Python. The discussion below
uses C++ syntax, but the translation to Python is trivial, except that
(a) Coords are handled as discussed above, and (b) the methods that
return a `std::vector` in C++ return a list in Python.

The constructor is

* `OffScreenCanvas(double ppu)`

	`ppu` is the pixels per unit that determines the conversion
    between user and pixel coordinates.  This is just an initial
    value.  It can be changed later by zooming, but some nonzero
    initial value is required.
	
##### Layer manipulation methods in `OffScreenCanvas`

* `CanvasLayer* OffScreenCanvas::newLayer(const std::string& name)`

	creates a new `CanvasLayer` with the given name.  The name is just
    for convenience and debugging.   All layers should be created with
    this method.
	
* `void OffScreenCanvas::deleteLayer(CanvasLayer *layer)`

	deletes a canvas layer from the Canvas and destroys it.  Do not
    simply delete a layer with `delete layer;`
	
* `void OffScreenCanvas::clear()`

	deletes all layers.
	
* `CanvasLayer* OffScreenCanvas::getLayer(int) const`

	gets a particular layer from the stack.  Layer 0 is the bottom
    layer.
	
* `Canvaslayer* OffScreenCanvas::getLayer(const std::string &name)
  const`
  
	  gets a layer by name.  The Python equivalent is
      `OffScreenCanvas.getLayerByName(name)`.  If you're going to use
      this, make sure that your layers have unique names.  OOFCanvas
      doesn't check for uniqueness.
	  
* `std::size_t OffScreenCanvas::nLayers() const`

	returns the total number of layers.
	
* `std::size_t OffScreenCanvas::nVisibleItems() const`

	returns the total number of visible items drawn on all layers.
	
* `void OffScreenCanvas::raiseLayer(int n, int howfar)`

	raises layer `n` by `howfar` places in the layer list.  A higher
    layer may hide the contents of a lower layer.  If `n` is too
    large, the layer will just be moved to the top.
	
* `void OffScreenCanvas::lowerLayer(int n, int howfar)`

	lowers layer `n` by `howfar` places in the layer list.  If `n` is
    too large, the layer will just be moved to the bottom.
	
* `void OffScreenCanvas::raiseLayerToTop(int n)`

	moves layer `n` to the top of the layer list.
	
* `void OffScreenCanvas::lowerLayerToBottom(int n)`

	moves layer `n` to the bottom of the layer list.
	
* `void OffScreenCanvas::reorderLayers(const
  std::vector<CanvasLayer*>* layerlist)`
  
  puts the layers in the order given in `layerlist`.  The list
  must contain all of the layers currently in the Canvas and no
  more. In Python the argument is a list `[]` of layers.
  
##### Output methods in `OffScreenCanvas`

* `bool OffScreenCanvas::saveAsPDF(const std::string& filename, int maxpix, bool bg)`

	saves the entire contents of the Canvas to a pdf file with the
    given name. 
	
	* Although the output should be independent of the pixel
      resolution, it's still necessary to pretend that there is a
      pixel size so that OOFCanvas can compute line thicknesses and
      other quantities that might be specified in pixel units.
      `maxpix` is the number of pixels to assume in the largest
      dimension of the image.
	  
	* If `bg` is true the background will be drawn.  Otherwise it will
      be left blank.
	  
	* The return value is true if something was drawn successfully.
	
* `bool OffScreenCanvas::saveAsPNG(...)`

	is the same as `saveAsPDF(...)` but writes a PNG file.
	  
* `bool OffScreenCanvas::saveRegionAsPDF(const std::string& filename,
  int maxpix, bool bg, 
  const Coord& pt0, const Coord& pt1)`
  
	  saves the rectangle defined by `pt0` and `pt1` to the given
      file.  `maxpix` and `bg` are the same as in `saveAsPDF`.  In the
      Python version, `pt0[0]` is the x coordinate of a corner, and
      `pt0[1]` is the y coordinate.
	  
* `bool OffScreenCanvas::saveRegionAsPNG(...)`

	is the same as `saveRegionAsPDF(...)` but writes a PNG file.
  
	
##### Miscellaneous methods in `OffScreenCanvas`

* `double OffScreenCanvas::getPixelsPerUnit() const`

	returns the current scale factor.
	
* `Coord OffScreenCanvas::pixel2user(const ICoord&) const`

	converts a pixel coordinate to a user coordinate.  The Python
    equivalent is `OffScreenCanvas.pixel2user(x,y)`, which returns a
    2-tuple. 
	
* `void OffScreenCanvas::setAntialias(bool)`

	turns anti-aliasing on and off.  The default value depends on your
    device.
	
* `void OffScreenCanvas::setMargin(double)`

	sets the size of the margin around the items on the canvas.  The
    size of the canvas is `1+margin` times the width and height of the
    bounding box of its contents.  The default value is 0.0.
	
* `bool OffScreenCanvas::empty() const`

	has anything been drawn?
	
* `OffScreenCanvas::setBackgroundColor(const Color&)`

	sets the color of the parts of the canvas where nothing has been
    drawn.
	
* `std::vector<CanvasItem*> OffScreenCanvas::clickedItems(const Coord&)`
  
	  returns a list of the `CanvasItems` at the given point, if the
      items are in clickable `CanvasLayer`. 
	  
* `std::vector<CanvasItem*> OffScreenCanvas::allItems() const`

	returns a list all `CanvasItems` on the Canvas, in all
    `CanvasLayers`.
	

#### Canvas (C++) {#Canvas}

`Canvas` is the C++ class that actually draws to the screen.  It is
derived from `[OffScreenCanvas]`(#offscreencanvas), and it creates a
`GtkLayout` when it is constructed.  The `GtkLayout` should be
inserted into the application's GUI.

The `Canvas` constructor is

```C++
Canvas::Canvas(double ppu)
```

ppu is the initial value to use for the pixels per unit scale factor
when the canvas is empty.  A new value will be computed if you call
`Canvas::zoomToFill()` after adding some `CanvasItems`, so the initial
`ppu` is nearly irrelevant.

All of the methods defined in `OffScreenCanvas` are available in
`Canvas`.  In addition, `Canvas` defines:

* `GtkWidget *Canvas::gtk() const`

	returns a pointer to the Canvas's `GtkLayout`.
	
* `void Canvas::destroy()`

	destroys the `GtkLayout`.  This is called automatically by the
    `Canvas` destructor, but it can be called manually if necessary
    for some reason.  Don't try to use the `Canvas` after destroying
    it.

* `void Canvas::show()`

	calls `gtk_widget_show` on the Canvas's `GtkLayout`.
	
* `void Canvas::draw()`
	
	instructs the Canvas to draw all of its `CanvasItems`.

* `int Canvas::widgetWidth() const`

	returns the width of the space allocated in the GUI for the
    `GtkLayout`.
	
* `int Canvas::widgetHeight() const`

	returns the height of the space allocated in the GUI for the
    `GtkLayout`.

* `void Canvas::zoom(double factor)`

	zooms the canvas by the specified factor, keeping the center point
    fixed.
	
* `void Canvas::zoomAbout(const Coord& fixedpt, double factor)`

	zooms the canvas by the specified factor, keeping the given point
    fixed.  The point is specified in user coordinates.
	
* `void Canvas::zoomToFill()`

	zooms the canvas so that all `CanvasItems` are visible and as
    large as possible.
	
* `void Canvas::center()`

	scrolls the canvas so that the center of bounding box of all
    `CanvasItems` is centered on the Canvas, without zooming.
	
* `Rectangle Canvas::visibleRegion() const`

	returns a `Rectangle` giving the user space coordinates of the
    visible part of the Canvas.
	
* `GtkAdjustment* Canvas::getHAdjustment() const`

	returns the `GtkAdjustment` that controls horizontal position of
    the canvas.  Connecting this object to a `GtkScrollBar` allows the
    canvas to be scrolled by the user.
	
* `GtkAdjustment* Canvas::getVAdjustment() const`

	is the same, for the vertical position of the canvas.
	
* `void Canvas::setMouseCallback(MouseCallback, void *data)`

	assigns a mouse click callback function, which will be called when
    the mouse button is pressed or released, the mouse is moved, or
    the scroll wheel is scrolled.  To limit the proliferation of
    motion events, see the `Canvas::allowMotionEvents` function.
	
	The signature of the callback function is
	
		```C++
		typedef void (*MouseCallback)(const std::string &event, 
	                              const Coord &position,
								  int button,
								  bool shift, bool ctrl,
								  void *data);
		```
	
	The following arguments are passed to the callback:
	
	* `const std:string& eventtype`
	
		The types are "down" (button was pressed), "up" (button was
        released), "move" (mouse was moved), and "scroll" (scroll
        wheel was turned).
		
	* `const Coord& position`
	
		The position of the mouse event, in user coordinates.
		
	* `int button`
	  
		  Which mouse button was used.
		  
	* `bool shift`
	
		Whether or not the shift key was pressed.
	
	* `bool ctrl`
	
		Whether or not the control key was pressed.
		
	* `void *data`
	
		The data pointer that was passed to `setMouseCallback`.
		
* `void Canvas::removeMouseCallback()`	

	removes the mouse callback function. 
	
* `MotionAllowed Canvas::allowMotionEvents(MotionAllowed ma)`

	tells the canvas how to respond when the mouse moves, if a mouse
    callback function is installed.  The values of `ma` in C++ are
	
	* `MotionAllowed::NEVER`: don't call the callback when the mouse moves.
	* `MotionAllowed::ALWAYS`: call the callback whenever the mouse moves.
	* `MotionAllowed::MOUSEDOWN`: call the callback when the mouse moves only
      if a mouse button is pressed.
	  
	In Python, the equivalents are the constants `motionNever`,
    `motionAlways`, and `motionMouseDown`.  <!-- TODO: Put this just in the
     !-- PythonCanvas section. -->

	The default value is `MotionAllowed::NEVER`, so you must
    explicitly allow motion events if you want them.
	
	`allowMotionEvents` returns the previous state of the motion
    handler, in case you want to restore it afterwards.
	  
* `void Canvas::setRubberBand(RubberBand*)`

	tells the canvas to start using the `RubberBand` object for
    displaying mouse motions.  See `RubberBand` for details.
	
* `void Canvas::removeRubberBand()`

	tells the canvas to stop using the rubberband.
	
* `void Canvas::setResizeCallback(ResizeCallback, void *data)`

	specifies a function to call when the canvas size changes.  The
    function must take a single `void*` argument, and return
    `void`. When called, the given `data` is passed.
	

#### Canvas (Python)

This is the `Canvas` class that is exported to Python.  It is really a
SWIG generated wrapper around a C++ class called `PythonCanvas`,
which is derived from [OffScreenCanvas](#offscreencanvas).

The Python `Canvas` creates a `GtkLayout` using Gtk's Python
interface.  The Gtk widget can be accessed directly via
`Canvas.layout`.

The constructor is

```python
Canvas(width, height, ppu, **kwargs)
```

where `width` and `height` are the desired size of the `GtkLayout`, in
pixels. `ppu` is the initial pixels per unit value.  Any additional
keyword arguments in `kwargs` are passed to the `GtkLayout`
constructor.

All of the methods available in `OffScreenCanvas` and in the C++
`Canvas` are also available in the Python `Canvas`, so refer to that
section [above](#Canvas) for the details.

In Python, the `Canvas` methods that set callback functions expect the
callbacks to be Python functions, but are otherwise just like the C++
functions: 

* `Canvas.setMouseCallback(callback, data)`

	installs a mouse callback function.  This is identical to the
    callback function in the C++ version, except 
	* It's a Python function, not a C++ function.
	* The `position` argument is a tuple, not a `Coord`.
	* The `data` is a Python object, not a `void*`.

* `Canvas.allowMotionEvents(ma)`

	is like the C++ version, telling the `Canvas` how to respond when
    the mouse moves, except that in C++ the argument is one of the
    constants `motionAlways`, `motionNever`, or `motionMouseDown`.
	
* `Canvas.setResizeCallback(callback, data)`

	Again, this is just like the C++ version, except the `callback`
    function is a Python function and `data` is a Python object.
	
### CanvasLayer

`CanvasLayers` hold sets of `CanvasItems`, which are the things that
are drawn on the Canvas. Layers may be raised, lowered, shown, and
hidden.

Layers should only be created by a `Canvas` (or `OffScreenCanvas`),
using its `newLayer()` method.

`CanvasLayer` methods include:

* `void CanvasLayer::clear()`

	removes all objects from the layer and makes it transparent.
	
* `void CanvasLayer::clear(const Color&)`

	removes all objects from the layer and fills it with the given
    `Color`.
	
* `void CanvasLayer::addItem(CanvasItem*)`

	adds the given item to the layer.  The layer owns the item.  After
    it's been added to the layer it should not be deleted except by
    clearing or destroying the layer.
	
* `void CanvasLayer::removeAllItems()`

* `bool CanvasLayer::empty() const`

	returns true if the layer contains no `CanvasItems`.

* `void CanvasLayer::destroy()`

	destroys the layer and removes it from the Canvas.
	
* `void CanvasLayer::show()`
  
	  makes the layer visible if it was previously hidden.  New layers
      are initially visible.
	  
* `void CanvasLayer::hide()`

	make the layer invisible.
	
* `void CanvasLayer::setClickable(bool)`

	If the argument is true, objects in the layer can be listed by
    `OffScreenCanvas::clickedItems()`.

* `void CanvasLayer::markDirty()`

	Force the layer to be redrawn the next time the `Canvas` is
    rendered.  Normally this shouldn't be needed.  Adding or removing
	a `CanvasItem` from a `CanvasLayer` makes it dirty.
	
* `void CanvasLayer::setOpacity(double)`

	sets the opacity with which the layer will be copied to the
    `Canvas` when it's displayed. 0.0 is fully transparent and 1.0 is
    fully opaque.
	
* `void CanvasLayer::raiseBy(int howfar) const`

	raises the layer in the Canvas by the given amount. This is the
    same as `OffScreenCanvas::raiseLayer(int n, int howfar)` except that you
    don't need to know the layer number `n`.
	
* `void CanvasLayer::lowerBy(int howfar) const`

	is the same as `raiseBy`, but in the other direction.
	
* `void CanvasLayer::raiseToTop() const`

	is the same as `OffScreenCanvas::raiseLayerToTop(int n)`.
	
* `void CanvasLayer::lowerToBottom() const`

	is the same as `OffScreenCanvas::lowerLayerToBottom(int n)`.
	
* `void CanvasLayer::writeToPNG(const std::string& filename)`
  
	  saves the contents of the layer to a PNG file.

### CanvasItem

`CanvasItem` is the base class for everything that can be drawn on the
canvas.

#### Abstract CanvasItem Subclasses

##### `CanvasShape`

This is an abstract base class for most other `CanvasItem` classes.
It defines the following methods:

* `void CanvasShape::setLineWidth(double)`
* `void CanvasShape::setLineWidthInPixels(double)`

	`setLineWidth` sets in the width in user
    units. `setLineWidthInPixels` sets it in pixel units.

* `void CanvasShape::setLineColor(const Color&)`

	See `Color`, below.

* `void CanvasShape::setLineJoin(Cairo::LineJoin)`

	In C++, the argument is a member of the [`Cairo::LineJoin`]
	(https://www.cairographics.org/documentation/cairomm/reference/classCairo_1_1Context.html)
	class.  In Python, it's `lineJoinMiter`, `1ineJoinRound`, or
	`lineJoinBevel`, which are defined in the OOFCanvas namespace.

* `void CanvasShape::setLineCap(Cairo::LineCap)`

	In C++, the argument is a member of the [`Cairo::LineCap`]
	(https://www.cairographics.org/documentation/cairomm/reference/classCairo_1_1Context.html)
	class.  In Python, it's `lineCapButt`, `lineCapRound`, or
	`lineCapSquare`, which are defined in the OOFCanvas namespace.

* `void CanvasShape::setDash(const std::vector<double>&, int offset)`

	The vector contains a pattern of dash lengths, which are in
	user units.  The pattern repeats as necessary.  `offset`
	indicates where the pattern starts.
	
* `void CanvasShape::setDashInPixels(const std::vector<double>&, int offset)`

	The same as the above `setDash`, but the dash lengths are
    interpreted in pixel units.

* `void CanvasShape::setDash(double)`

	Use a single dash length, which is in user units.

* `void CanvasShape::setDashInPixels(double)`

	The same as `setDash(double)`, but the dash lengths are in pixel
    units.


* `void CanvasShape::setDashColor(const Color&)`

	Fill the spaces between dashes with the given color,
	instead of leaving them blank.
	
* `void CanvasShape::unsetDashes()`

	Turn off dashes. Draw solid lines.
			
##### `CanvasFillableShape`

This abstract class in derived from `CanvasShape` and is used for
closed shapes that can be filled with a color.  It provides one
method:

* `void CanvasFillableShape::setFillColor(const Color&)`

	Fill the shape with the given color.

#### Concrete CanvasItem Subclasses

##### `CanvasArrowhead`

An arrowhead can be placed on a `CanvasSegment`.  The
`CanvasArrowhead` class is *not* derived from `CanvasShape`.  Its
constructor is
	
* `CanvasArrowHead(const CanvasSegment *segment, double position, bool reversed)`
		
	`segment` is the `CanvasSegment` that the arrowhead will be drawn
	on. `
	
	`position` ranges from 0.0 to 1.0, and determines where the tip of
	the arrow will appear on the segment.  A value of 0.0 puts the tip
	at the first point of the segment, and a value of 1.0 puts it at
	the second point.  The color of the arrowhead is the same as the
	line color of the `CanvasSegment`.
	
The size of the arrowhead is set by either

* `void CanvasArrowHead::setSize(double width, double length)`

	`width` and `length` are in user units.

or

* `void CanvasArrowHead::setSizeInPixels(double width, double length)`

	`width` and `length` are in pixels.
	
Either `setSize()` or `setSizeInPixels()` *must* be called before an
arrowhead can be drawn.

##### `CanvasCircle`

Derived from `CanvasFillableShape`.  Its constructor is
	
* `CanvasCircle(const Coord &center, double radius)`
	
The coordinates of the center and the radius are in user units.  To
specify the radius in pixels, use [`CanvasDot`](#`CanvasDot`) instead.

##### `CanvasCurve`

A `CanvasCurve` is a set of line segments connected end to end.  It is
derived from `CanvasShape`, but not `CanvasFillableShape`.  It is
specified by listing the sequence of points joined by the segments.
Its constructors are
	
* `CanvasCurve()`

	Create an empty curve, containing no points.  This constructor
	must be used in Python.

* `CanvasCurve(int n)` 

	Create a curve with room reserved for `n` points, but don't
	actually create the points.

* `CanvasCurve(const std::vector<Coord> &points)`

	Create a curve with the given points.

Points can be added to a `CanvasCurve` via

* `void CanvasCurve::addPoint(const Coord&)`

or 

* `void CanvasCurve::addPoints(const std::vector<Coord>*)`

In Python, the argument to `addPoints` is a list of Coord-like (ie,
indexable) objects.

`int CanvasCurve::size()` returns the number of points in the curve.

##### `CanvasDot`

Derived from `CanvasFillableShape`, a `CanvasDot` is a circle with a
fixed size in pixels.  Its line width is also always measured in
pixels.  The constructor is

* `CanvasDot(const Coord &center, double radius)`


##### `CanvasEllipse`

Derived from `CanvasFillableShape`.  The constructor is

* `CanvasEllipse(const Coord &c, const Coord &r, double angle)`

where `c` is the center in user coordinates and the components of `r`
are the radii in user units.  `r[0]` is the radius in the x direction
before rotation.  The rotation angle in degrees is measured
counterclockwise.
	
##### `CanvasImage`

`CanvasImage` can display a PNG file, or if compiled with the
[ImageMagick](https://imagemagick.org/index.php) library, any format
that ImageMagick can read.  To enable ImageMagick, define
`OOFCANVAS_USE_IMAGEMAGICK` when building OOFCanvas.

The constructor creates an empty image:

* `CanvasImage(const Coord &position, const ICooord &npixels)`

where `position` is the position of the lower left corner of the
image in user coordinates.

*Confusion Opportunity!*  There are two kinds of pixels.  There are the
pixels on your computer screen, and there are the pixels in the
`CanvasImage`.  They don't have to be the same size.  A `CanvasImage`
may be displayed at a different scale from its natural size, in which
case one `CanvasImage` pixel will be larger or smaller than one screen
pixel.

Since an empty image isn't very useful, `CanvasImage` includes some
static factory methods for creating `CanvasImage` objects. 

* Create a blank image:

	```C++
	CanvasImage* CanvasImage::newBlankImage(
           const Coord& position,
		   const ICoord& pixelsize,
		   const Color &color);
   ```

	The image is filled with a single color, `color`, so it's not
	really blank.  `position` is the user coordinate of the lower left
	corner of the image. `size` is the size that it will be drawn, in
	user units. `pixelsize` is the size of the image in pixels.

* Read a png file:

	```C+++
	CanvasImage* CanvasImage::newFromPNGfile(
		   const Coord &position,
		   const std::string& filename)
	```

	`position` is the position of the lower left corner of the image
	in user coordinates, and `size` is its displayed size, in user
	units. 
   
* Read any file format that ImageMagick can handle:

	```C++
	CanvasImage* CanvasImage::newFromImageMagickFile(
		   const Coord& position,
		   const std::string& filename)
	```

	`position` is the position of the lower left corner of the image
	in user coordinates, and `size` is its displayed size.

* Create a CanvasImage from ImageMagick data:

	```C++
	CanvasImage* CanvasImage::newFromImageMagick(
		const Coord& position,
		Magick::Image imagedata)
   ```

	Create a `CanvasImage` from image data that has already been read
	by [ImageMagick](https://imagemagick.org/index.php).  The data is
	copied from the ImageMagick structure.


`CanvasImage` provides the following useful methods:

* Set the displayed size of the image, in user coordinates:

	`void CanvasImage::setSize(const Coord&)`
	
	or in pixel (screen) coordinates:
	
	`void CanvasImage::setSizeInPixels(const Coord&)`
	
	Either `setSize` or `setSizeInPixels` *must* be called before an
    image can be displayed.

* Set the style for drawing individual pixels

	`CanvasImage::setDrawIndividualPixels(flag)`

	Cairo draws pixels as small fuzzy blobs, which may or may not be
    what you want, especially if you need to zoom in.  When examining
    data on the image pixel level (not the screen pixel level) it can
    be convenient to draw each pixel as a rectangle.  Call
    `setDrawIndividualPixels(true)` to switch to this mode, or
    `setDrawIndividualPixels(false)` to turn it off.
	
* Examine individual pixels

	`Color CanvasImage::get(const ICoord &) const;`
	
	This returns the color of the pixel at the given point in the image.
	The `ICoord` is the location of the pixel in the *image*, not the
    canvas.  As such, it uses standard image coordinates, with x
    increasing from left to right and y increasing from top to bottom.
	
* Modify individual pixels

	`void CanvasImage::set(const ICoord&, const Color&)`

	The `ICoord` is the location of the pixel in the *image*, not the
    canvas.  As such, it uses standard image coordinates, with x
    increasing from left to right and y increasing from top to bottom.
	
	If you need to make extensive modifications to an image, it's
    better to use some other tools first and then load the modified
    image into the `CanvasImage`.
	
* Set overall opacity

	`void CanvasImage::setOpacity(double alpha)`
	
	This sets the opacity for the entire image, used when it is copied
    to the `Canvas`.  It doesn't actually change any image data.


##### `CanvasPolygon`

A `CanvasPolygon` is a closed `CanvasCurve`, derived from
`CanvasFillableShape`.  It is specified by listing the corners of the
polygon, counterclockwise.  Its constructors are

* `CanvasPolygon()`

	Create an empty polygon, containing no points.  This constructor
    must be used in Python.
	
* `CanvasPolygon(int n)`

	Create a polygon with room for `n` points, but don't actually
    create the points.  Points must be added with `addPoints`.
	
* `CanvasPolygon(const std::vector<Coord>& points)`

	Create a polygon from the given vector of `Coords`.
	
To add points to a polygon, in C++ use either

* `CanvasPolygon::addPoint(double x, double y)`
* `CanvasPolygon::addPoint(const Coord&)`

or

* `CanvasPolygon::addPoints(const std::vector<Coord>*)`

In Python, use

* `CanvasPolygon.addPoint(x, y)`
* `CanvasPolygon.addCoord(pt)`

	where `pt` is some kind of point object, with `pt[0]` being x and
    `pt[1]` being y.

or

* `CanvasPolygon::addPoints(ptlist)`

	where `ptlist` is a list of point objects `pt`, where `pt[0]` is x and
    `pt[1]` is y.

##### `CanvasRectangle`

Derived from `CanvasFillableShape`.  The constructor is 

* `CanvasRectangle(const Coord&, const Coord&)`

where the `Coord`s are the user coordinates of any two opposite
corners of the rectangle.
			
##### `CanvasSegment`

A single line segment, derived from `CanvasShape`.  The
constructor is

* `CanvasSegment(const Coord &point0, const Coord &point1)`

The positions are given in user coordinates.
		
##### `CanvasSegments`

'CanvasSegments` is derived from `CanvasShape` and draws a set of
unconnected line segments all with the same color and width.

The constructors are

* `CanvasSegments()`

	creates an empty object.
	
* `CanvasSegments(int n)`

	allocates space for `n` segments, but doesn't create them.  This
    form is only available in C++.
	
To add segments to the object, use

* `CanvasSegments::addSegment(const Coord &pt0, const Coord &p1)`

	The segment goes from `pt0` to `pt1`.
	
##### `CanvasText`

`CanvasText` displays text at an arbitrary position and orientation.
It is derived from `CanvasItem`.  The text is drawn by the
[Pango](https://pango.gnome.org/) library.

The constructor is

* `CanvasText(const Coord &location, const std::string &text)`

where `location` is the position of the lower left corner of the text, in
user coordinates.

`CanvasText` methods include

* `CanvasText::setFillColor(const Color& color)`

	sets the color of the text.
	
* `CanvasText::setFont(const std::string &fontdesc, bool inPixels)`

	`fontdesc` is a string that will be passed to
    [`pango_font_description_from_string()`]
	(https://docs.gtk.org/Pango/type_func.FontDescription.from_string.html)
    to determine the font.  It includes a font family or families,
    style options, and size (for example, `"Times Bold 0.2"`).  The
    size is interpreted in pixels if `inPixels` is true and in
    user units otherwise. The names of the installed font families
    are returned by the `list_fonts()` function.
	
* `CanvasText::rotate(angle)`

	rotates the text by the given angle, in degrees, about the left
    end of the text's baseline.  Positive angles are counterclockwise.

### RubberBand

Rubberbands are dashed lines drawn on top of the rest of the Canvas to
indicate mouse movements while a mouse button is pressed.  The
rubberband will be drawn while the mouse is down if a mouse callback
calls `GUICanvasBase::setRubberBand(RubberBand*)`. 
<!-- TODO: IS THAT RIGHT? IT DOESNT HAVE TO BE CALLED BY THE CALLBACK. -->
Drawing will cease
after `GUICanvasBase::removeRubberBand()` is called.

The current position of the mouse
will be passed to the rubberband's `draw()` method whenever the mouse
is moved.  Various kinds of rubberbands are defined in `rubberband.h`.
To stop displaying the rubberband, pass `nullptr` (in C++) or `None`
(in Python) to `setRubberBand()`.  OOFCanvas does *not* take ownership
of the rubberband object.  The calling code must delete it when done
with it in C++ (if necessary) and make sure to retain a reference to
it in Python (when necessary).

Five subclasses of `RubberBand` are defined:

* `LineRubberBand` is a straight line from the mouse-down position to
  the current position.
  
* `RectangleRubberBand` is rectangle with one corner at the mouse-down
  position and the diagonally opposite corner at the current position.
  
* `CircleRubberBand` is a circle centered on the mouse-down position
  and passing through the current position.
  
* `EllipseRubberBand` is an ellipse that is fit into a rectangle, as
	in `RectangleRubberBand`.
	
* `SpiderRubberBand` is a set of line segments, starting at given
  points and ending at the current mouse position.  The start points
  are specified by calling `SpiderRubberBand::addPoints(list)`, where
  in C++, `list` is a `std::vector<Coord>*`.  In Python, it's a
  iterable collection of objects where `obj[0]` is the x component of
  `obj` and `obj[1]` is its y component.
  
The appearance of the rubberband is controlled by these functions in
the `RubberBand` base class:

* `void RubberBand::setLineWidth(double width)`

	width is the line width in pixel units.
	
* `void RubberBand::setColor(const Color& color)`

	sets the color of the dashed line.
	
* `void RubberBand::setDashLength(double length)`

	sets the length of the dashes in pixels.
	
* `void RubberBand::setDashColor(const Color &color)`

	sets the color of the line *between* the dashes.  If this function
    is not called, the spaces between the dashes are not filled.
	
* `void RubberBand::setDashed(bool)`

	turns the dashes on and off.  Undashed rubberbands drawn with
    solid lines may be hard to see on some backgrounds.  The default
    is to draw dashes.


## Appendix: Adding new CanvasItem subclasses

New `CanvasItem` subclasses can be derived from `CanvasItem`,
`CanvasShape`, or `CanvasFillableShape`.  A `CanvasShape`  is a
`CanvasItem` with predefined methods for setting line drawing
parameters.  A `CanvasFillableShape` is a `CanvasShape` with
predefined methods for setting a fill color.

The derived class constructor must invoke the base class constructor,
passing a `Rectangle` as the argument.  The rectangle is the item's
bounding box: the smallest rectangle in user space that
completely encloses the item.  The sides of the rectangle are aligned
with the x and y axes.  If the bounding box is not known, an
uninitialized rectangle (`Rectangle()`) can be passed.

### `CanvasItem`

A `CanvasItem` must define three virtual methods:

* `void drawItem(Cairo::RefPtr<Cairo::Context> context) const`

	Draw the item to the given `Cairo::Context`, using Cairo
    functions.

* `bool containsPoint(const OffScreenCanvas*, const Coord&) const`

	Return true if the given point (in user coordinates)
    is inside the `CanvasItem`.   If the item isn't selectable by
    clicking, this method can always return false.
	
* `std::string print() const`

	Return a descriptive string.  Used for debugging.
	
In addition, the `CanvasItem` must provide information about its
bounding box in one of two ways, depending on whether or not the
bounding box size is known when the item is first built: 

1. Set `bbox` in the constructor.  `bbox` is a `Rectangle`
   stored in the `CanvasItem` base class.
   
2. Redefine `const Rectangle& findBareBoundingBox() const` in the
   derived class.  This returns the `Rectangle` that the item would
   occupy in user coordinates if the pixel size were zero (i.e, if
   the `ppu` were infinite).
   
   Also, redefine `void pixelExtents(double& left, double& right,
   double& up, double& down) const` in the derived class.  The four
   arguments must be set to the distances, in pixel units, that the
   item extends beyond its bare bounding box. The values will
   generally be nonzero only if the item has components whose size is
   specified in pixels instead of user units. If all sizes are in
   physcial units, then the bare bounding box is the actual bounding
   box, and all pixel extents are zero.  In that case, `pixelExtents`
   does not have to be redefined in the derived class.
   
Any operation that changes an item's size after it's been added to a
`CanvasLayer` should call 'void CanvasItem::modified()`.

### `CanvasShape`

`CanvasShape` is an intermediate base class for `CanvasItems` that
draw lines.  All of the lines must have the same color, width, and
other characteristics.  `CanvasShape` does not store the lines -- it
only provides the machinery for setting their style parameters.  The
subclass's `drawItem` method should set up a Cairo path and then call
`CanvasShape::stroke(context)` to draw it, where `context` is the
`CairoContext` that was passsed to `drawItem()`.

### `CanvasFillableShape`

`CanvasFillableShape` is another intermediate base class for
`CanvasItems`.  It extends `CanvasShape` by adding a method for
setting a fill color.  When `CanvasFillableShape::stroke(context)` is
called, it draws lines and fill shapes with the current settings.

## Appendix: Internal Order of Operations

It shouldn't be necessary to understand this section in order to use
OOFCanvas.  It's here to help development.

Each `CanvasLayer` contains a `Cairo::ImageSurface` which contains a
bitmap of what's been drawn in the layer, a `Cairo::Context` which
controls drawing to surface, and a `Rectangle` which is the bounding box
(in user coordinates) of all of the layer's `CanvasItems`. 

When a `CanvasItem` is added to a `CanvasLayer`, the layer is marked
"dirty" and the item is stored in the layer.  No drawing is done at
this point.

When all items have been added to the layers, calling
`GUICanvasBase::draw()` generates a draw event on the `GtkLayout`.  This
causes `GUICanvasBase::drawHandler()` to be called.  The argument to
drawHandler is the `Cairo::Context` for drawing to the `GtkLayout`'s
`Cairo::Surface`. 

`GUICanvasBase::drawHandler()` begins by computing the horizontal and
vertical offsets that will be used to keep the image centered in
the gtk window (if the image is smaller than the window) or at the
position determined by the scroll bars (if the image is larger than
the window).

Next, drawHandler calls `Canvas::setTransform()`, which computes the
matrix that converts from user coordinates to bitmap coordinates
within the layer, given the ppu.  The `GtkLayout` is resized if
necessary so that it is large enough to accomodate the bounding boxes
of all of the layers, plus an optional margin (set by
`OffScreenCanvas::setMargin()`).  Note that a layer's bounding box, in
user units, can depend on the ppu if the layer contains items with
sizes given in pixels.

What happens next depends on whether or not a rubberband is being
drawn.  If there is no rubberband, `GUICanvasBase::drawHandler` draws the
background color and then, for each layer from bottom to top, tells
the layer to draw all of its `CanvasItems`s to its own `Cairo::ImageSurface`
(`CanvasLayer::render()`), and copies the layer's surface to the
`GtkLayout`'s surface (`CanvasLayer::copyToCanvas()`) at the position
given by the scroll bars.  (`CanvasLayer::render()` only redraws its
items if any have changed since the last time they were drawn.)

If there is an active rubberband, on the first call to `drawHandler`
after the mouse button was  pressed all of the `CanvasLayer`s other
than the rubberband's layer are rendered to a separate
`Cairo::ImageSurface` called the `nonRubberBandBuffer`.  Then this
buffer is copied to the `GtkLayout` and the rubberband is drawn on top
of it.  On subsequent calls to `drawHandler`, the
`nonRubberBandBuffer` is copied and the rubberband is drawn, but the
`nonRubberBandBuffer` is not rebuilt unless the layers have changed.

---
### Disclaimer and Copyright

NIST-developed software is provided by NIST as a public service. You
may use, copy and distribute copies of the software in any medium,
provided that you keep intact this entire notice. You may improve,
modify and create derivative works of the software or any portion of
the software, and you may copy and distribute such modifications or
works. Modified works should carry a notice stating that you changed
the software and should note the date and nature of any such
change. Please explicitly acknowledge the National Institute of
Standards and Technology as the source of the software. To facilitate
maintenance we ask that before distributing modified versions of this
software, you first contact the authors at oof_manager@nist.gov.

NIST-developed software is expressly provided "AS IS." NIST MAKES NO
WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY
OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT
AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR WARRANTS THAT THE
OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, OR THAT
ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY
REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR THE RESULTS
THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY,
RELIABILITY, OR USEFULNESS OF THE SOFTWARE.

You are solely responsible for determining the appropriateness of
using and distributing the software and you assume all risks
associated with its use, including but not limited to the risks and
costs of program errors, compliance with applicable laws, damage to or
loss of data, programs or equipment, and the unavailability or
interruption of operation. This software is not intended to be used in
any situation where a failure could cause risk of injury or damage to
property. The software developed by NIST employees is not subject to
copyright protection within the United States.







					 





